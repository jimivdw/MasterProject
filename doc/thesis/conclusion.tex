\chapter{Conclusion}
\chlab{conclusion}

In an attempt to speed up the molecule parameterisation process, we have developed a new approach that uses fragments of parameterised molecules to find the charges of individual atoms in an unparameterised molecule. We implemented this new approach in a system called the Online tool for Fragment-based Molecule Parameterisation~(\oframp). Two different versions of it were designed, called \IDa\ and \IDb, and have been compared by performing a user study.

From the user study, we have concluded that the \IDb\ interaction design allows users to be done quicker, while the \IDa\ version yields more accurate results. The users showed a strong preference for the \IDa\ design. They liked the overview they had of the matching fragments, and felt like they were more in control than in the \IDb\ version. This has turned out to be an important aspect, and is required to make a good parameterisation of a molecule.

In addition to this, users rated the \IDa\ version better than the \IDb\ one. With a \verb|SUS| score of 76, it is even rated higher than the average system, and good in general. For the complex task of fragment-based molecule parameterisation, we consider user satisfaction and result correctness to be the most valuable aspects of the system. Therefore, the \IDa\ interaction design has been selected as the overall better of the two.

More in general, most of the common features of the two versions were appreciated as well. First, the graphical design of the application was found to be very clean and clear, and noted to look professional. Second, users were enthusiastic about the way in which the molecules are visualised, the ability to move them around and scale them, and the responsiveness of the visualisation. The selection details window was found to be very useful, and the demo mode helped them to quickly learn how to use the system. Finally, although not everyone used it, the help pages were highly appreciated for their extensive descriptions of every aspect of \oframp.

There were, of course, also some negative comments. Often, the found fragments were not ordered correctly, and the best available match rarely ended up on top of the list. Furthermore, there were even situations in which barely matching fragments were rated to be very good. Although the development of the fragment finding system was not a part of this project, it needs to be improved further in order for \oframp{} to be able to attain its full potential.

Additionally, many suggestions for improvements and additions to the system have been provided. They span from the addition of an auto-select mode for atoms, to the modification of certain atom colours. The suggestions need to be evaluated in order to determine which of them are useful, and which are not. Implementing the right suggestions will definitely help to improve the quality of \oframp\ even further.

Once all alterations to the system have been made, we believe that it will become a tool using which a parameterisation can be obtained that can compete with one obtained using the conventional quantum-mechanical calculations. Furthermore, chemists will be able to fully parameterise a molecule using \oframp{} in less time than when using the conventional methods.

All these findings support our hypotheses, which were posed in \secref{ra_hypotheses}. The \IDb\ interaction design we presented turned out to take up less time than the \IDa\ one. This version in turn, delivered more accurate results, was rated higher by its users, and is therefore considered the overall better version. Using \oframp, it should definitely be possible to create a molecule parameterisation of equal quality to the calculated ones, in less time.

Finally, from a general interaction design perspective, the findings of this project suggest that for complex, unexplored tasks like fragment-based molecule parameterisation, the best results can be obtained using a design that gives the user full control over the system. Without a validated set of rules on how exactly the task needs to be performed, automating certain parts of the system might overlook complex aspects of the task and therefore result in bad output. For this type of tasks, one should rather implement a non-automated version of the system first, in order to establish a set of rules for the automation. Later, the possibility of automating (parts of) the process using those rules can be examined.
